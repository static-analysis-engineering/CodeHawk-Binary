#!/usr/bin/env python3
# ------------------------------------------------------------------------------
# CodeHawk Binary Analyzer
# Author: Henny Sipma
# ------------------------------------------------------------------------------
# The MIT License (MIT)
#
# Copyright (c) 2021-2024  Aarno Labs, LLC
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ------------------------------------------------------------------------------
"""Command-line interface to the CodeHawk Binary Analyzer.

These are common commands to analyze an executable and view the
analysis results (<xname> is name of executable):

get information:
   info                show configuration information
   version             show version of analyzer and python api

disassemble/analyze an executable:
  These commands extract the content of the executable into xml and store
  the various levels of results in the directory <name>.ch.
  Extraction and disassembly are fairly fast (seconds to minutes), whereas
  full analysis, is strongly dependent on the size and structure of the
  executable, and for large or very complex executables may take several hours.

  The commands are:
    analyze <xname>      extract executable content, disassemble, and analyze
    analyze -d <xname>   extract executable content and disassemble
    analyze -x <xname>   only extract executable content into xml

When a file is disassembled the following commands can be used to output
ELF or PE header information:

    pedata <xname>       output PE header, import tables, etc.
    elfdata <xname>      output ELF header and program and section headers

When a file is fully analyzed the following commands are available to query
the analysis results:

    results stats <xname>         output a summary of results with one line per function
    results functions <xname> ... output a listing of annotated assembly functions
    results callgraph <xname> ... output a callgraph in dot/pdf format
    results function <xname> <fn> output a listing of a single annotated assembly function
    results cfg <xname> <fn> ...  produce a control flow graph for a function (in pdf)
    results cfgpaths <xname> <fn> ... find paths throug a cfg with a given target
    results branchconditions <xname> <fn>  output branch conditions for the given function

    results appcalls <xname>      output a listing of application calls (PE32 only)
    results dllcalls <xname>      output a listing of dll calls (PE32 only)
    results iocs <xname>          output a listing of indicators of compromise encountered (PE32 only)

    results extract <xname>       extract tables

The analyzer comes with a large collection of summaries for library functions.
These summaries can be queried independently of any executable with the following
commands:

    summaries stats  output some statistics on summaries/constants/data structures provided

    summaries dlls   output a listing of dlls provided
    summaries enums  output a listing of enum type definitions provided

    summaries dll-functions output a listing of functions in a dll
    summaries so-functions  output a listing of shared-object functions

    summaries dll-function  output signature and summary semantics for a dll-function
    summaries so-function   output signature and summary semantics for a shared-object function

    summaries enum          output the values included in an enum definition

    summaries ioc-types     output a listing of indicator-of-compromise categories
    summaries ioc-roles     output a listing of indicator-of-compromise role names per category

The python interface has a limited capability to perform (symbolic) simulation,
based on the results of the analysis. Simulation can be performed with the
following commands:

    simulate <xname> <fn>   run a (symbolic) simulation of the given function

The python interface has a capability to perform a relational analysis of two executables.
The two executables can be related from different perspectives (syntactic or semantic) and
different levels of precision (e.g., control flow graph vs expressions). The commands to
perform this relational analysis are

    relational <xname1> <xname2> ....

The repository includes regression tests. They are organized by file format (pe, elf) and
architecture (x86, mips32, arm32) and further divided into test suites that combine tests
with similar structure. These tests can be run with the following commands:

    test runall --arch <arch> --fileformat <file-format>
    test runsuite <arch> --fileformat <file-format> <suite number>
    test run <arch> <file-format> --suite <suite number> --test <test number>
    test run all
    test run --suite <suite number> all

The test programs themselves can also be listed and viewed:

    test list --arch <arch> --fileformat <file-format> --suite <suite number>
    test view <arch> --fileformat <file-format> <suite number> <test number>
"""

import argparse
import json
import os
import shutil
import subprocess
import sys

from typing import NoReturn

from chb.app.CHVersion import chbversion
import chb.app.AppAccess as AP

import chb.cmdline.AnalysisManager as AM
import chb.cmdline.aprcmds as APR
import chb.cmdline.astcmds as AST
import chb.cmdline.commandutil as UCC
import chb.cmdline.structcmds as USC
import chb.cmdline.runcmds as UR
import chb.cmdline.fileformatcmds as FF
import chb.cmdline.relationalcmds as R
import chb.cmdline.simulatecmds as S
import chb.cmdline.reportcmds as REP
import chb.cmdline.summariescmds as SC
import chb.cmdline.testcmds as TC
import chb.cmdline.typeconstraintcmds as TYC

import chb.util.dotutil as UD
import chb.util.fileutil as UF
import chb.util.loggingutil as UL
from chb.util.Config import Config

import chb.graphics.DotCfg as DC

from chb.util.DotGraph import DotGraph


def showversion(args: argparse.Namespace) -> NoReturn:
    print("CodeHawk-Binary Analyzer (python) Version: " + chbversion)
    config = Config()
    chx86_analyze = Config().chx86_analyze
    cmd = [chx86_analyze, "version"]
    subprocess.call(cmd, stderr=subprocess.STDOUT)
    exit(0)


def showinfo(args: argparse.Namespace) -> NoReturn:
    print(str(Config()))
    exit(0)


def resultscommand(args: argparse.Namespace) -> NoReturn:
    print("The results command can be followed by the following subcommands:")
    print("All commands take the name of the executable as first argument")
    print("")
    print("  stats <xname>                show statistics for the executable")
    print("  functions <xname> ....       output annotated assembly functions for the specified functions")
    print("  callgraph <xname> ....       output callgraph in dot/pdf format")
    print("  cfg <xname> <faddr>          create control flow graph for the given function")
    print("  cfgpaths <xname> <faddr> ... extract paths through the control flow graph for the given function")
    print("  branchconditions <xname> <faddr>  show branch conditions for the given function")
    print("  fileio <xname>               show files opened by the application")
    exit(0)


def relationalcommand(args: argparse.Namespace) -> NoReturn:
    print("The relational command can be followed by the following subcommands:")
    print("")
    print("  prepare <xname1> <xname2> ... prepare executable for relational analysis")
    print("")
    print("  compare functions <xname1> <xname2>")
    print("  compare function <xname1> <xname2> <faddr1> <faddr2>")
    print("  compare invariants <xname1> <xname2> <faddr1> <faddr2>")
    print("  compare cfg <xname1> <xname2> <faddr1> <faddr2>")
    print("")
    print("The prepare subcommand will analyze the binary <xname2>, possibly")
    print("adding hints for added ELF sections or trampolines to be inlined.")
    print("Note that for some binaries this may take a long time")
    print("")
    print("For more information on the compare subcommand type")
    print("  chkx relational compare")
    exit(0)


def relationalcomparecommand(args: argparse.Namespace) -> NoReturn:
    print(
        "The relational compare command command can be followed by the following "
        + "subcommands:")
    print("")
    print("  functions <xname1> <xname2>")
    print("     list which functions have changed or have been deleted or added")
    print("")
    print("  function <xname1> <xnam2> <faddr1> <faddr2>")
    print("     only compare the functions faddr1 in xname1 and faddr2 in xname2")
    print("")
    print("  invariants <xname1> <xname2> <faddr1> <faddr2>")
    print("     list which location invariants have changed/disappeared/appeared")
    print("     at corresponding locations in faddr1 in xname1 and faddr2 in xname2")
    print("")
    print("  cfg <xname1> <xname2> <faddr1> <faddr2>")
    print("     render the cfgs of faddr1 in xname1 and faddr2 in xname2")
    print("     side-by-side, with changed basic blocks colored differently")
    exit(0)


def tablecommand(args: argparse.Namespace) -> NoReturn:
    print('The table command can be followed by the following subcommands:')
    print('  expr')
    exit(0)


def testcommand(args: argparse.Namespace) -> NoReturn:
    print("The test command can be followed by the following subcommands:")
    print("  runall")
    exit(0)


def summariescommand(args: argparse.Namespace) -> NoReturn:
    print("The summaries command provides access to function summaries.")
    print("It can be followed by the following subcommands:")
    print("  list dlls                     output a list of dlls provided")
    print("  list dll_functions --dlls <dll-1> .. <dll-n>  output a list of summaries in the given dlls")
    print("  list so_functions             output a list of shared object functions (ELF)")
    exit(0)


def summarieslistcommand(args: argparse.Namespace) -> NoReturn:
    print("The summaries list command provides access to function summaries.")
    print("It can be followed by the following subcommands:")
    print("  dlls          output a list of dlls provided (per jarfile)")
    print("  dll-functions <dll-1> ... <dll-n> output a list of functions for each dll listed")
    print("  so-functions  output a list of shared-object functions (ELF)")
    exit(0)


def summariesviewcommand(args: argparse.Namespace) -> NoReturn:
    print("The summaries view command outputs one or more summaries.")
    print("It can be followed byt the following subcommands:")
    print("  dll-function   output signature and summary semantics for a dll function")
    print("  so-function    output signature and summary semantics for an so function")
    print("  dll-functions  output signature and summary semantics for multiple dll functions")
    print("  so-functions   output signature and summary semantics for multiple so functions")
    exit(0)


def simulatecommand(args: argparse.Namespace) -> NoReturn:
    print("The simulate command allows simulation of a single function.")
    exit(0)


'''
def reportappcalls(args):
    (path,filename) = UC.get_path(args.xname,checkresults=True)
    xinfo = UC.get_xinfo(path,filename)
    if xinfo.is_mips():
        UC.print_not_supported('Not yet supported for mips')
    app = AP.AppAccess(path,filename)
    appcalls = app.get_app_calls()
    result = {}  #  faddr -> [ instr ]
    for faddr in sorted(appcalls):
        for instr in appcalls[faddr]:
            tgt = str(instr.get_call_target().get_address())
            result.setdefault(tgt,[])
            result[tgt].append(instr)
    for tgt in sorted(result):
        print('\n' + str(tgt))
        for instr in sorted(result[tgt],key=lambda i:i.asmfunction.faddr):
            faddr = instr.asmfunction.faddr
            iaddr = instr.iaddr
            print('    ' + faddr + ',' + iaddr
                  + ': ' + ', '.join(str(x) for x in instr.get_call_arguments()))

def reportdllcalls(args):
    (path,filename) = UC.get_path(args.xname,checkresults=True)
    xinfo = UC.get_xinfo(path,filename)
    if xinfo.is_mips() or xinfo.is_elf():
        UC.print_not_supported('Not supported for elf')
    app = AP.AppAccess(path,filename)
    dllcalls = app.get_dll_calls()
    result = {}  # name of dll -> name of function -> [ instr ]
    for faddr in dllcalls:
        for instr in dllcalls[faddr]:
            tgt = instr.get_call_target().get_stub()
            dll = tgt.get_dll()
            fname = tgt.get_name()
            result.setdefault(dll,{})
            result[dll].setdefault(fname,[])
            result[dll][fname].append(instr)
    print(UC.dll_results_tostring(args,result))

def reportiocs(args):
    (path,filename) = UC.get_path(args.xname,checkresults=True)
    xinfo = UC.get_xinfo(path,filename)
    if not xinfo.is_pe32():
        UC.print_not_supported('Only supported for PE32')
    app = AP.AppAccess(path,filename)
    try:
        (iocresults,problems) = app.get_ioc_arguments() # ioc -> role-name -> (faddr,iaddr,arg)
    except UF.CHBError as e:
        print(str(e.wrap()))
        exit(1)
    print(UC.ioc_results_tostring(args,iocresults,problems))

'''


def parse() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__,
        epilog='See for more information ...')
    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        exit(0)
    subparsers = parser.add_subparsers(title='subcommands')
    parser_info = subparsers.add_parser('info')
    parser_info.set_defaults(func=showinfo)

    parser_version = subparsers.add_parser('version')
    parser_version.set_defaults(func=showversion)

    # ------------------------------------------------------------ analyze --
    analyzecmd = subparsers.add_parser("analyze")
    analyzecmd.add_argument("xname", help="name of executable")
    analyzecmd.add_argument(
        "-d", "--disassemble",
        action='store_true',
        help="extract and disassemble only")
    analyzecmd.add_argument(
        "--save_datablocks",
        help="save datablocks in range <startaddr>:<endaddr>")
    analyzecmd.add_argument(
        "-o", "--outputfile",
        help="name of json file (without extension) to save datablocks")
    analyzecmd.add_argument(
        "--vardefs",
        action="store_true",
        help="analyze variable definitions with symbolic sets")
    analyzecmd.add_argument(
        '-x', "--extract",
        action='store_true',
        help="extract executable content only")
    analyzecmd.add_argument(
        '--reset',
        action='store_true',
        help='remove existing analysis results')
    analyzecmd.add_argument(
        '--resetx',
        action='store_true',
        help='remove extracted binary (chx.tar.gz) and analysis results')
    analyzecmd.add_argument(
        "--exclude_debug",
        action="store_true",
        help="do not extract debug sections")
    analyzecmd.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="output intermediate information")
    analyzecmd.add_argument(
        "--save_asm",
        default="yes",
        choices=["yes", "no"],
        help='save asm listing in analysis directory')
    analyzecmd.add_argument(
        "--construct_all_functions",
        action="store_true",
        help="construct all functions even if not all functions are analyzed")
    analyzecmd.add_argument(
        "--collect_diagnostics",
        action="store_true",
        help="save diagnostics in a separate diagnostics log file")
    analyzecmd.add_argument(
        "--thumb",
        nargs="*",
        default=[],
        help="arm-thumb switch points (format <hex-addr>:T or <hex-addr>:A)")
    analyzecmd.add_argument(
        "--iterations",
        type=int,
        default=11,
        help="maximum number of iterations")
    analyzecmd.add_argument(
        "--ssa",
        action="store_true",
        help=("use single static assignment; this will be applied only in the "
              + "final round"))
    analyzecmd.add_argument(
        "--arm_extension_registers",
        action="store_true",
        help=(
            "include arm-extension-registers (floating-point registers) in the "
            + "analysis"))
    analyzecmd.add_argument(
        "--analysisrepeats",
        type=int,
        default=1,
        help="number of analyses to be performed per cycle")
    analyzecmd.add_argument(
        '--preamble_cutoff',
        type=int,
        default=12,
        help='minimum cutoff for function entry preamble')
    analyzecmd.add_argument(
        '--thirdpartysummaries',
        nargs="*",
        default=[],
        help='summary jars for third party libraries')
    analyzecmd.add_argument(
        "--so_libraries",
        nargs="*",
        default=[],
        help="names of shared-object summary libraries to search")
    analyzecmd.add_argument(
        '--hints',
        nargs="*",
        default=[],
        help='names of json files with disassembly/analysis hints')
    analyzecmd.add_argument(
        "--headers",
        nargs="*",
        default=[],
        help="names of c header files with summaries/data structures")
    analyzecmd.add_argument(
        "--skip_if_asm",
        help="skip if assembly code is already present",
        action="store_true")
    analyzecmd.add_argument(
        "--skip_if_metrics",
        help="skip if analysis results are already present",
        action="store_true")
    analyzecmd.add_argument(
        "--fns_no_lineq",
        nargs="*",
        default=[],
        help="addresses of functions not to analyze with linear equalities")
    analyzecmd.add_argument(
        "--fns_exclude",
        nargs="*",
        default=[],
        help="addresses of functions to exclude from the analysis")
    analyzecmd.add_argument(
        "--fns_include",
        nargs="*",
        default=[],
        help="addresses of function to include in the analysis")
    analyzecmd.add_argument(
        "--gc_compact",
        type=int,
        default=0,
        help="invoke ocaml garbage collector after analyzing n number of functions")
    analyzecmd.add_argument(
        "--show_function_timing",
        action="store_true",
        help="print out timing after every function's analysis")
    analyzecmd.add_argument(
        "--lineq_instr_cutoff",
        type=int,
        default=0,
        help="disable relational analysis for functions with more instructions")
    analyzecmd.add_argument(
        "--lineq_block_cutoff",
        type=int,
        default=0,
        help="disable relational analysis for functions with more basic blocks")
    analyzecmd.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    analyzecmd.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    analyzecmd.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    analyzecmd.set_defaults(func=UCC.analyzecmd)

    # --------------------------------------------------------- PE/ELF data ---
    pedatacmd = subparsers.add_parser("pedata")
    pedatacmd.add_argument("xname", help="name of executable")
    pedatacmd.add_argument(
        "--headeronly",
        action="store_true",
        help="show only the PE header")
    pedatacmd.add_argument(
        "--imports",
        action="store_true",
        help="show only import tables")
    pedatacmd.add_argument(
        "--headers",
        action="store_true",
        help="show only section headers")
    pedatacmd.add_argument(
        "--sections",
        action='store_true',
        help="show only sections")
    pedatacmd.add_argument(
        "--section",
        help="show only section at given address")
    pedatacmd.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    pedatacmd.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    pedatacmd.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    pedatacmd.set_defaults(func=FF.pedatacmd)

    elfdatacmd = subparsers.add_parser("elfdata")
    elfdatacmd.add_argument("xname", help="name of executable")
    elfdatacmd.add_argument(
        "--save_section_headers",
        action="store_true",
        help="save the section headers in json format")
    elfdatacmd.add_argument(
        "--libs",
        action="store_true",
        help="only show dynamically linked libraries")
    elfdatacmd.add_argument(
        "--header",
        action="store_true",
        help="only show elf header and dynamically linked libraries")
    elfdatacmd.add_argument(
        "--opcodestats",
        help=("json filename (without extension) to save opcode statistics"))
    elfdatacmd.set_defaults(func=FF.elfdatacmd)

    # ----------------------------------------------------------------- results --
    resultscmd = subparsers.add_parser('results')
    resultscmd.set_defaults(func=resultscommand)
    resultsparsers = resultscmd.add_subparsers(title='show options')

    # -- results stats --
    resultsstats = resultsparsers.add_parser('stats')
    resultsstats.add_argument('xname', help='name of executable')
    resultsstats.add_argument(
        '--nocallees',
        action='store_true',
        help='indicate if a function has no callees')
    resultsstats.add_argument(
        "--sortby",
        help=("sort by function-address (default), function-size, or function "
              + "analysis time"),
        choices=["faddr", "instrs", "basicblocks", "time", "loopdepth"],
        default="faddr")
    resultsstats.add_argument(
        "--timeshare",
        type=int,
        help="list percentage of time used by <n> most expensive functions",
        default=0)
    resultsstats.add_argument(
        "--opcodes",
        help=("json filename (without extension) to save opcode distribution "
              + "stats (for instructions within analyzed functions)"))
    resultsstats.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    resultsstats.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    resultsstats.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")
    resultsstats.set_defaults(func=UCC.results_stats)

    # -- results callgraph --
    resultscg = resultsparsers.add_parser("callgraph")
    resultscg.add_argument("xname", help="name of executable")
    resultscg.add_argument(
        "--output", "-o",
        required=True,
        help=("basename of file to save output (without extension); "
              + "a file with extension .dot and a file with extension .pdf "
              + "will be produced"))
    resultscg.add_argument(
        "--hide_lib_functions",
        action="store_true",
        help="hide nodes representing library targets")
    resultscg.add_argument(
        "--hide_unknown_targets",
        action="store_true",
        help="hide nodes of unknown targets")
    resultscg.add_argument(
        "--reverse",
        action="store_true",
        help="reverse call graph (reverse edges)")
    resultscg.add_argument(
        "--align",
        choices=["no", "left", "right", "both"],
        default="both",
        help="align nodes on the left and/or right side (left takes precedence)")
    resultscg.add_argument(
        "--sources",
        nargs="*",
        default=[],
        help="list of names of starting nodes to constrain callgraph")
    resultscg.add_argument(
        "--sinks",
        nargs="*",
        default=[],
        help="list of names of terminal nodes to constrain callgraph")
    resultscg.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    resultscg.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    resultscg.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    resultscg.set_defaults(func=UCC.results_callgraph)

    # -- results ast
    buildast = resultsparsers.add_parser("ast")
    buildast.add_argument("xname", help="name of executable")
    buildast.add_argument(
        "--outputfile", "-o",
        help="name of file to save symboltables and asts (without extension)")
    buildast.add_argument(
        "--functions",
        help="address (in hex) of functions to be included in ast",
        nargs="*",
        default=[])
    buildast.add_argument(
        "--hints",
        help="names of json files with userdata hints",
        nargs="*",
        default=[])
    buildast.add_argument(
        "--patch_results_file",
        help="name of patch results file (required if there are trampolines)")
    buildast.add_argument(
        "--remove_edges",
        nargs="*",
        default=[],
        help="list of edges to be removed (in the form faddr:src-addr:tgt-addr in hex)")
    buildast.add_argument(
        "--add_edges",
        nargs="*",
        default=[],
        help="list of edges to be added (in the form faddr:src-addr:tgt-addr in hex)")
    buildast.add_argument(
        "--verbose", "-v",
        action="store_true")
    buildast.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    buildast.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    buildast.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    buildast.set_defaults(func=AST.buildast)

    # -- results decompile (abstract syntax tree) --
    showast = resultsparsers.add_parser("decompile")
    showast.add_argument("xname", help="name of executable")
    showast.add_argument(
        "--exclude",
        help="exclude from decompilation",
        nargs="*",
        default=[])
    showast.add_argument(
        "--functions",
        help="addresses (in hex) of functions to be included in ast",
        nargs="*",
        default=[])
    showast.add_argument(
        "--hints",
        help="names of json files with userdata hints",
        nargs="*",
        default=[])
    showast.add_argument(
        "--verbose", "-v",
        help="print spans and available expressions",
        action="store_true")
    showast.add_argument(
        "--showdiagnostics",
        help="print diagnostics to the console",
        action="store_true")
    showast.set_defaults(func=AST.showast)

    # -- results cfg (control flow graph) --
    showcfg = resultsparsers.add_parser("cfg")
    showcfg.add_argument("xname", help="name of executable")
    showcfg.add_argument("faddr", help="address of function (in hex)")
    showcfg.add_argument(
        "--output", "-o",
        help="basename of file to save output (without extension)")
    showcfg.add_argument(
        "--json",
        action="store_true",
        help="save control flow graph in json (no dot/pdf is produced)")
    showcfg.add_argument(
        "--format",
        choices=["pdf", "png"],
        default="pdf",
        help="format for the graph file generated from dot")
    showcfg.add_argument(
        '--view',
        action="store_true",
        help="open a viewer on the pdf file")
    showcfg.add_argument(
        '--predicates',
        action="store_true",
        help="add branch predicates")
    showcfg.add_argument(
        '--calls',
        action="store_true",
        help="add calls to nodes")
    showcfg.add_argument(
        "--instr_opcodes",
        action="store_true",
        help="add all assembly instruction opcode text to nodes")
    showcfg.add_argument(
        "--instr_text",
        action="store_true",
        help="add all assembly instruction annotations to nodes")
    showcfg.add_argument(
        "--stores",
        action="store_true",
        help="add assembly instruction annotations that store a value in memory")
    showcfg.add_argument(
        '--sink',
        help='restrict graph to paths to this basic block')
    showcfg.add_argument(
        '--segments',
        nargs="*",
        default=[],
        help='restrict graph to paths that include these basic blocks')
    showcfg.add_argument(
        "--derivedgraph",
        action="store_true",
        help="print nodes of derived sequence graph")
    showcfg.add_argument(
        "--save_edges",
        action="store_true",
        help="save edges as a json file with the same name as the pdf output")
    showcfg.add_argument(
        "--remove_edges",
        nargs="*",
        default=[],
        help="list of edges to be removed (in the form src-addr:tgt-addr in hex)")
    showcfg.add_argument(
        "--add_edges",
        nargs="*",
        default=[],
        help="list of edges to be added (in the form src-addr:tgt-addr in hex)")
    showcfg.set_defaults(func=UCC.showcfg)

    # --- results functions ---
    resultsfunctions = resultsparsers.add_parser('functions')
    resultsfunctions.add_argument('xname', help='name of executable')
    resultsfunctions.add_argument(
        "--functions",
        nargs='*',
        default=[],
        help="list of function addresses (in hex) (default is all functions) ")
    resultsfunctions.add_argument(
        "--bytes",
        action="store_true",
        help="include instruction bytes")
    resultsfunctions.add_argument(
        "--hash",
        action='store_true',
        help='show md5 hash')
    resultsfunctions.add_argument(
        "--bytestring",
        action='store_true',
        help='show bytes as a string')
    resultsfunctions.add_argument(
        "--opcodewidth",
        type=int,
        default=40,
        help='number of characters for opcode text')
    resultsfunctions.add_argument(
        "--stacklayout",
        action="store_true",
        help="include stacklayout at the top of the function")
    resultsfunctions.add_argument(
        "--proofobligations",
        action="store_true",
        help="include proofobligations at the top of the function")
    resultsfunctions.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    resultsfunctions.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    resultsfunctions.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    resultsfunctions.set_defaults(func=UCC.results_functions)

    # --- results function ---
    resultsfunction = resultsparsers.add_parser(
        "function",
        description="Outputs the annotated assembly listing of a function")
    resultsfunction.add_argument("xname", help="name of executable")
    resultsfunction.add_argument("faddr", help="hex address of function")
    resultsfunction.add_argument(
        "--json",
        action="store_true",
        help="produce output in json format (note: this may be large)")
    resultsfunction.add_argument(
        "--output", "-o", help="save output in file")
    resultsfunction.add_argument(
        "--bytes",
        action="store_true",
        help="include instruction bytes")
    resultsfunction.add_argument(
        "--md5hash",
        action="store_true",
        help="show function md5 hash")
    resultsfunction.add_argument(
        "--bytestring",
        action="store_true",
        help="show function as a string of bytes")
    resultsfunction.add_argument(
        "--opcodewidth",
        type=int,
        default=32,
        help="number of characters for opcode text")
    resultsfunction.add_argument(
        "--stacklayout",
        action="store_true",
        help="include stacklayout at the top of the function")
    resultsfunction.add_argument(
        "--proofobligations",
        action="store_true",
        help="include proofobligations at the top of the function")
    resultsfunction.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    resultsfunction.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    resultsfunction.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    resultsfunction.set_defaults(func=UCC.results_function)

    # --- results apr ---
    resultsapr = resultsparsers.add_parser("apr")
    resultsapr.add_argument("xname", help="name of executable")
    resultsapr.add_argument(
        "outputfile",
        help="name of json outputfile (without extension)")
    resultsapr.add_argument(
        "--callees",
        nargs="*",
        default=[],
        help="callees to be repaired")
    resultsapr.set_defaults(func=APR.patchdata)

    # --- results callback tables ---
    resultscallbacktables = resultsparsers.add_parser("callbacktables")
    resultscallbacktables.add_argument("xname", help="name of executable")
    resultscallbacktables.add_argument(
        "--showall",
        action="store_true",
        help="print the addresses and contents of all callback tables")
    resultscallbacktables.add_argument(
        "--list",
        action="store_true",
        help="list the addresses and structure of callback tables present")
    resultscallbacktables.add_argument(
        "--output", "-o",
        help="filename to save callbacktable(s) to json format (no extension)")
    resultscallbacktables.add_argument(
        "--device",
        help="name of device to store in outputfile")
    resultscallbacktables.set_defaults(func=UCC.results_callbacktables)

    # --- results invariants ---
    resultsinvariants = resultsparsers.add_parser(
        "invariants",
        description=(
            "Lists the invariants at every instruction address in the function. "
            + "Invariants are assertions about the program state at a particular "
            + "location before that instruction is executed"))
    resultsinvariants.add_argument("xname", help="name of executable")
    resultsinvariants.add_argument("faddr", help="hex address of function")
    resultsinvariants.add_argument(
        "--json",
        action="store_true",
        help=(
            "produce output in json format (--include and --exclude "
            + "arguments are ignored in this case)"))
    resultsinvariants.add_argument(
        "--output", "-o", help="save output in file")
    resultsinvariants.add_argument(
        "--include",
        nargs="*",
        default=[],
        help=(
            "only include invariants that contain this string (only applies "
            + "for text output)"))
    resultsinvariants.add_argument(
        "--exclude",
        nargs="*",
        default=[],
        help=(
            "exclude invariants that contain this string (only applies "
            + " for text output)"))
    resultsinvariants.set_defaults(func=UCC.results_invariants)

    # --- results functioninfo ---
    resultsfinfo = resultsparsers.add_parser(
        "functioninfo",
        description=(
            "Lists the function information collected during analysis"))
    resultsfinfo.add_argument("xname", help="name of executable")
    resultsfinfo.add_argument("faddr", help="hex address of function")
    resultsfinfo.set_defaults(func=UCC.results_finfo)

    # --- results branchconditions ---
    resultsbranchconditions = resultsparsers.add_parser("branchconditions")
    resultsbranchconditions.add_argument("xname", help="name of executable")
    resultsbranchconditions.add_argument(
        "function", help="hex address of function")
    resultsbranchconditions.set_defaults(func=UCC.results_branchconditions)

    # --- results structures ---
    resultsstructs = resultsparsers.add_parser("structs")
    resultsstructs.add_argument("xname", help="name of executable")
    resultsstructs.add_argument(
        "--arguments",
        action="store_true",
        help="restrict struct values to arguments")
    resultsstructs.set_defaults(func=USC.results_structs)

    # --- results extract ---
    resultsextract = resultsparsers.add_parser("extract")
    resultsextract.add_argument("xname", help="name of executable")
    resultsextract.add_argument("addr", help="start address of object to extract")
    resultsextract.add_argument(
        "out", help="filename to save results (without extension)")
    resultsextract.add_argument(
        "--structure",
        nargs="*",
        default=["hex"],
        help="specification of record fields (int, str, hex, or fp)")
    resultsextract.add_argument(
        "--structtable",
        action="store_true",
        help="extract structtable at the given address")
    resultsextract.add_argument(
        "--callbacktable",
        action="store_true",
        help="extract callback table at the given address")
    resultsextract.add_argument(
        "--callbacktables",
        action="store_true",
        help="extract all callback tables")
    resultsextract.add_argument(
        "--showtags",
        action="store_true",
        help="if structure has a field called tags, print all tags")
    resultsextract.add_argument(
        "--stringtables",
        nargs="*",
        help="include multiple tables consisting of strings")
    resultsextract.add_argument(
        "--size",
        type=int,
        default=0,
        help="number of records to extract (default: end by zero termination)")
    resultsextract.set_defaults(func=UCC.results_extract)

    # --- results fileio ---
    resultsfileio = resultsparsers.add_parser("fileio")
    resultsfileio.add_argument("xname", help="name of executable")
    resultsfileio.set_defaults(func=UCC.results_fileio)

    # -- results cfgpaths (paths through the control flow graph) --
    resultscfgpaths = resultsparsers.add_parser("cfgpaths")
    resultscfgpaths.add_argument("xname", help="name of executable")
    resultscfgpaths.add_argument("faddr", help="hex address of function")

    targetgroup = resultscfgpaths.add_mutually_exclusive_group(required=True)
    targetgroup.add_argument(
        "--calltarget",
        help="address or name of call target (e.g., strcpy)")
    targetgroup.add_argument(
        "--block",
        help='address of target block to reach')

    resultscfgpaths.add_argument(
        "--graph",
        help="name of dot/pdf file (without extension)")
    resultscfgpaths.add_argument(
        "--conditions",
        help="show conditions along the path",
        action='store_true')
    resultscfgpaths.add_argument(
        "--calls",
        help='show calls made per basic block',
        action='store_true')
    resultscfgpaths.add_argument(
        "--stringconstraints",
        help='output string constraints',
        action='store_true')
    resultscfgpaths.add_argument(
        "--maxtime",
        type=int,
        help='maximum search time (in secs)')
    resultscfgpaths.set_defaults(func=UCC.showcfgpaths)

    # -- results global variables
    resultsglobals = resultsparsers.add_parser("globalvars")
    resultsglobals.add_argument("xname", help="name of executable")
    resultsglobals.set_defaults(func=UCC.results_globalvars)

    # ----------------------------------------------------- type constraints ---
    parser_typeconstraints = subparsers.add_parser("typeconstraints")
    parser_typeconstraints.set_defaults(func=TYC.typeconstraintcommand)
    typeconstraintparsers = parser_typeconstraints.add_subparsers(
        title="show options")

    # --- typeconstraints signatures -----------------------------------------
    tc_signatures = typeconstraintparsers.add_parser("signatures")
    tc_signatures.add_argument("xname", help="name of executable")
    tc_signatures.set_defaults(func=TYC.tc_signatures_cmd)

    # ------------------------------------------------------ report subcommand
    parser_report = subparsers.add_parser("report")
    parser_report.set_defaults(func=REP.reportcommand)
    reportparsers = parser_report.add_subparsers(title='show options')

    # -- report on memory operations --
    report_memops = reportparsers.add_parser("memops")
    report_memops.add_argument("xname", help="name of executable")
    report_memops.set_defaults(func=REP.report_memops)

    # -- report calls
    report_calls = reportparsers.add_parser("calls")
    report_calls.add_argument("xname", help="name of executable")
    report_calls.add_argument(
        "--callee",
        help="name or hex address of call target",
        required=True)
    report_calls.add_argument(
        "--json",
        help="output results in json format",
        action="store_true")
    report_calls.add_argument(
        "--output", "-o", help="name of output file (without extension)")
    report_calls.add_argument(
        "--cgpathsrc",
        help=(
            "name or hex address of application function to be used as "
            + " source for callgraph path"))
    report_calls.set_defaults(func=REP.report_calls_cmd)

    # -- report function api's
    report_functionapis = reportparsers.add_parser("function_apis")
    report_functionapis.add_argument("xname", help="name of executable")
    report_functionapis.add_argument(
        "--details",
        action="store_true",
        help="show functions without signature")
    report_functionapis.set_defaults(func=REP.report_function_apis)

    # -- report proof obligations
    report_proofobligations = reportparsers.add_parser("proofobligations")
    report_proofobligations.add_argument("xname", help="name of executable")
    report_proofobligations.set_defaults(func=REP.report_proofobligations)


    # --- report unresolved
    report_unresolved = reportparsers.add_parser("unresolved")
    report_unresolved.add_argument("xname", help="name of executable")
    report_unresolved.add_argument(
        "outputfile",
        help="name of json output file (without extension)")
    report_unresolved.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="print instructions with unresolved calls/jumps/loads/stores")
    report_unresolved.set_defaults(func=REP.report_unresolved)

    '''

    # -- report application calls --
    report_appcalls = reportparsers.add_parser('appcalls')
    report_appcalls.add_argument('xname',help='name of executable')
    report_appcalls.set_defaults(func=reportappcalls)

    # -- report dll calls --
    report_dllcalls = reportparsers.add_parser('dllcalls')
    report_dllcalls.add_argument('xname',help='name of executable')
    report_dllcalls.add_argument('--aggregate',help='aggregate argument values per dll function',
                                 action='store_true')
    report_dllcalls.set_defaults(func=reportdllcalls)

    # -- report indicators of compromise --
    report_iocs = reportparsers.add_parser('iocs')
    report_iocs.add_argument('xname',help='name of executable')
    report_iocs.add_argument('--verbose','-v',help='show locations of iocs',
                             action='store_true')
    report_iocs.add_argument('--constants','-c',action='store_true',
                             help='only show values that are constant literals')
    report_iocs.set_defaults(func=reportiocs)
    '''

    # -------------------------------------------------------------- summaries subcommand

    parser_summaries = subparsers.add_parser("summaries")
    parser_summaries.set_defaults(func=SC.summariescommand)
    summariesparsers = parser_summaries.add_subparsers(title="show options")

    # --- stats ---
    summaries_stats = summariesparsers.add_parser("stats")
    summaries_stats.set_defaults(func=SC.summaries_stats_cmd)

    # --- dlls ---
    summaries_dlls = summariesparsers.add_parser("dlls")
    summaries_dlls.set_defaults(func=SC.summaries_dlls_cmd)

    # --- enums ---
    summaries_enums = summariesparsers.add_parser("enums")
    summaries_enums.set_defaults(func=SC.summaries_enums_cmd)

    # --- dll-functions ---
    summaries_dll_functions = summariesparsers.add_parser("dll-functions")
    summaries_dll_functions.add_argument(
        "dll", help="name of dll")
    summaries_dll_functions.set_defaults(func=SC.summaries_dll_functions_cmd)

    # --- so-functions ---
    summaries_so_functions = summariesparsers.add_parser("so-functions")
    summaries_so_functions.set_defaults(func=SC.summaries_so_functions_cmd)

    # --- dll-function
    summaries_dll_function = summariesparsers.add_parser("dll-function")
    summaries_dll_function.add_argument("dll", help="name of dll")
    summaries_dll_function.add_argument("function", help="name of function")
    summaries_dll_function.set_defaults(func=SC.summaries_dll_function_cmd)

    # --- so-function
    summaries_so_function = summariesparsers.add_parser("so-function")
    summaries_so_function.add_argument(
        "function", help="name of function")
    summaries_so_function.set_defaults(func=SC.summaries_so_function_cmd)

    # --- enum ---
    summaries_enum = summariesparsers.add_parser("enum")
    summaries_enum.add_argument(
        "name", help="name of enum definition")
    summaries_enum.set_defaults(func=SC.summaries_enum_cmd)

    # --- ioc-types ---
    summaries_ioc_types = summariesparsers.add_parser("ioc-types")
    summaries_ioc_types.set_defaults(func=SC.summaries_ioc_types_cmd)

    # --- ioc-roles ---
    summaries_ioc_roles = summariesparsers.add_parser("ioc-roles")
    summaries_ioc_roles.set_defaults(func=SC.summaries_ioc_roles_cmd)

    # ---------------------------------------------------- relational subcommand
    relationalcmd = subparsers.add_parser("relational")
    relationalcmd.set_defaults(func=relationalcommand)
    relationalparsers = relationalcmd.add_subparsers(title="show options")

    # --- relational prepare --
    relationalprepare = relationalparsers.add_parser(
        "prepare",
        description=(
            "This command will compare the section headers of binary <xname2> "
            + "with those of binary <xname1> to identify added or removed sections, "
            + "and changes in starting address or size of the sections. "
            + "In addition, if the userdata of <xname1> has arm-thumb switchpoints, "
            + "these are added to the userdata of <xname2>. If new code was inserted, "
            + "it is assumed that this code includes a trampoline, which is added to "
            + "the userdata as well. It is assumed that the same c header files "
            + "apply as for <xname1>. If only a subset of the functions in the "
            + "original binary, <xname1> were analyzed, only those will be analyzed "
            + "in the patched version, <xname2>, to avoid the analysis reporting "
            + "them as added functions"))
    relationalprepare.add_argument(
        "xname1", help="name of first (original) executable (assumed analyzed)")
    relationalprepare.add_argument(
        "xname2",
        help="name of second (patched) executable to be prepared for comparison")
    relationalprepare.add_argument(
        "--json",
        action="store_true",
        help="produce output in json format")
    relationalprepare.add_argument(
        "-output", "-o", help="save output in file")
    relationalprepare.add_argument(
        "--save_aux_userdata",
        help="name of json file (without extension) to save auxiliary userdata")
    relationalprepare.add_argument(
        "--save_asm",
        action="store_true",
        help="save the assembly file")
    relationalprepare.add_argument(
        "--hints",
        nargs="*",
        default=[],
        help="names of files with userdata for the original application (xname1)")
    relationalprepare.add_argument(
        "--headers",
        nargs="*",
        default=[],
        help="names of c header files with summaries/data structures")
    relationalprepare.add_argument(
        "--construct_all_functions",
        action="store_true",
        help=("construct all functions, even if not all functions are analyzed"))
    relationalprepare.add_argument(
        "--ssa",
        action="store_true",
        help=(
            "use single static assignment for the analysis of the patched binary; "
            + " this will be applied only in the final round"))
    relationalprepare.add_argument(
        "--patch_results_file",
        help="name of patch results file (required if the patch includes trampolines)")
    relationalprepare.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    relationalprepare.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    relationalprepare.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    relationalprepare.set_defaults(func=R.relational_prepare_command)

    # --- relational compare --
    relationalcompare = relationalparsers.add_parser("compare")
    relationalcompare.set_defaults(func=relationalcomparecommand)
    relationalcompareparsers = relationalcompare.add_subparsers(title="show options")

    # --- relational compare app --
    relationalcomparefns = relationalcompareparsers.add_parser("app")
    relationalcomparefns.add_argument(
        "xname1", help="name of first (original) executable (assumed analyzed)")
    relationalcomparefns.add_argument(
        "xname2", help="name of second (patched) executable (assumed analyzed)")
    relationalcomparefns.add_argument(
        "--usermapping", help="name of json file with initial function mapping")
    relationalcomparefns.add_argument(
        "--patch_results_file",
        help="name of patch results file (required if there are trampolines)")
    relationalcomparefns.add_argument(
        "--json",
        action="store_true",
        help="produce output in json format")
    relationalcomparefns.add_argument(
        "--output", "-o", help="save output in file")
    relationalcomparefns.set_defaults(func=R.relational_compare_app_cmd)

    # --- relational compare function --
    relationalcomparefn = relationalcompareparsers.add_parser("function")
    relationalcomparefn.add_argument(
        "xname1", help="name of first (original) executable (assumed analyzed)")
    relationalcomparefn.add_argument(
        "xname2", help="name of second (patched) executable (assumed analyzed)")
    relationalcomparefn.add_argument(
        "--addresses",
        default=[],
        nargs="*",
        help="list of hex addresses of (original) functions to be included")
    relationalcomparefn.add_argument(
        "--patch_results_file",
        help="name of patch results file (required if there are trampolines)")
    relationalcomparefn.add_argument(
        "--blocks",
        action="store_true",
        help="give details on all functions that were modified at the block level")
    relationalcomparefn.add_argument(
        "--details",
        action="store_true",
        help="give details on all functions that were modified at the instruction level")
    relationalcomparefn.add_argument(
        "--usermapping", help="name of json file with initial function mapping")
    relationalcomparefn.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    relationalcomparefn.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    relationalcomparefn.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")
    relationalcomparefn.add_argument(
        "--json",
        action="store_true",
        help="produce output in json format")
    relationalcomparefn.add_argument(
        "--output", "-o", help="save output in file")
    relationalcomparefn.set_defaults(func=R.relational_compare_function_cmd)

    # --- relational compare cfgs --
    relationalcomparecfgs = relationalcompareparsers.add_parser("cfgs")
    relationalcomparecfgs.add_argument(
        "xname1", help="name of first (original) executable (assumed analyzed)")
    relationalcomparecfgs.add_argument(
        "xname2", help="name of second (patched) executable (assumed analyzed)")
    relationalcomparecfgs.add_argument(
        "outputfilename",
        help="output filename (without extension)")
    relationalcomparecfgs.add_argument(
        "--patch_results_file",
        help="name of patch results file (required if there are trampolines)")
    relationalcomparecfgs.add_argument(
        "--show_calls",
        action="store_true",
        help="show functions called in cfg basic blocks")
    relationalcomparecfgs.add_argument(
        "--show_predicates",
        action="store_true",
        help="show predicates on the edges of the cfg")
    relationalcomparecfgs.add_argument(
        "--usermapping", help="name of json file with initial function mapping")
    relationalcomparecfgs.add_argument(
        "--format",
        choices=["pdf", "png"],
        default="pdf",
        help="format for the generated file")
    relationalcomparecfgs.add_argument(
        "--json",
        action="store_true",
        help="store results in json (all other optional arguments are ignored")
    relationalcomparecfgs.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    relationalcomparecfgs.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    relationalcomparecfgs.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    relationalcomparecfgs.set_defaults(func=R.relational_compare_cfgs_cmd)

    # --- relational compare invariants --
    relationalcompareinvs = relationalcompareparsers.add_parser("invariants")
    relationalcompareinvs.add_argument(
        "xname1", help="name of first (original) executable (assumed analyzed)")
    relationalcompareinvs.add_argument(
        "xname2", help="name of second (patched) executable (assumed analyzed)")
    relationalcompareinvs.add_argument(
        "--usermapping", help="name of json file with initial function mapping")
    relationalcompareinvs.add_argument(
        "--loglevel", "-log",
        choices=UL.LogLevel.options(),
        default="NONE",
        help="activate logging with the given level (default to stderr)")
    relationalcompareinvs.add_argument(
        "--logfilename",
        help="name of file to write log messages")
    relationalcompareinvs.add_argument(
        "--logfilemode",
        choices=["a", "w"],
        default="a",
        help="file mode for log file: append (a, default), or write (w)")

    relationalcompareinvs.set_defaults(func=R.relational_compare_invs_cmd)

    # --- relational_compare md5s
    relationalcomparemd5s = relationalcompareparsers.add_parser("md5s")
    relationalcomparemd5s.add_argument(
        "xname1", help="name of first (original) executable (assumed analyzed)")
    relationalcomparemd5s.add_argument(
        "xname2", help="name of second (patched) executable (assumed analyzed)")
    relationalcomparemd5s.set_defaults(func=R.relational_compare_md5s_cmd)

    # ------------------------------------------------------ simulate subcommand
    parser_simulate = subparsers.add_parser("simulate")
    parser_simulate.add_argument("xname", help="name of executable")
    parser_simulate.add_argument("faddr", help="hex address of functions")
    parser_simulate.add_argument(
        "--steps", help="number of simulation steps", type=int, default=100)
    parser_simulate.add_argument(
        "--libs",
        nargs="*",
        default=[],
        help="shared objects to be included in the simulation (format name:file)")
    parser_simulate.add_argument(
        "--support",
        help="custom import initializations and file/network interactions")
    parser_simulate.add_argument(
        "--stub_imports",
        nargs="*",
        default=[],
        help="custom import of user-defined stubs")
    parser_simulate.add_argument(
        "--mainargs", nargs="*", help="arguments passed to main", default=[])
    parser_simulate.add_argument(
        "--optargaddr", help="address where optarg is stored")
    parser_simulate.add_argument(
        "--optargstate",
        help="alternative address where optarg is stored (uclibc)")
    parser_simulate.add_argument(
        "--patched_globals",
        nargs="*",
        help="globals with modified values (format: hexaddr:hexvalue)",
        default=[])
    parser_simulate.add_argument(
        "--config_values",
        nargs="*",
        help="filename of dictionary that maps keys to values")
    parser_simulate.add_argument(
        "--environment_variables",
        nargs="*",
        help="filenames of dictionaries that map names to values")
    parser_simulate.add_argument(
        "--envptr_addr",
        help="hex address of location that holds pointer to the environment variables")
    parser_simulate.set_defaults(func=S.simulate_function_cmd)

    # -------------------------------------------------------- tables subcommand
    parser_table = subparsers.add_parser('table')
    parser_table.set_defaults(func=tablecommand)
    tableparsers = parser_table.add_subparsers(title='show options')

    table_tc = tableparsers.add_parser("type_constraints")
    table_tc.add_argument("xname", help="name of executable")
    table_tc.set_defaults(func=UCC.show_type_constraint_table)

    # --- expr ---
    table_expr = tableparsers.add_parser('expr')
    table_expr.add_argument('xname', help='name of executable')
    table_expr.add_argument("faddr", help="hex address of executable")
    table_expr.set_defaults(func=UCC.show_expr_table)

    # --- variables ---
    table_vars = tableparsers.add_parser('variables')
    table_vars.add_argument('xname', help='name of executable')
    table_vars.add_argument("faddr", help="hex address of executable")
    table_vars.set_defaults(func=UCC.show_vars_table)

    # --- invariants ---
    table_invs = tableparsers.add_parser('invariants')
    table_invs.add_argument('xname', help='name of executable')
    table_invs.add_argument("faddr", help="hex address of executable")
    table_invs.set_defaults(func=UCC.show_invariant_table)

    # --- variable invariants ---
    table_varinvs = tableparsers.add_parser("varinvariants")
    table_varinvs.add_argument("xname", help="name of executable")
    table_varinvs.add_argument("faddr", help="hex address of executable")
    table_varinvs.set_defaults(func=UCC.show_var_invariant_table)

    # ----------------------------------------------------------- deserialize
    parser_deserialize = subparsers.add_parser("deserialize")
    parser_deserialize.add_argument(
        "filename",
        help="name of json ast file to be deserialized")
    parser_deserialize.set_defaults(func=AST.deserialize)

    # ---------------------------------------------------------- run commands
    parser_runcmds = subparsers.add_parser("runcmds")
    parser_runcmds.add_argument("cname", help="name of command file (json)")
    parser_runcmds.add_argument(
        "--targets",
        help="list of targets to be executed",
        nargs="*",
        default=[])
    parser_runcmds.add_argument(
        "--showtargets",
        help="show targets available",
        action="store_true")
    parser_runcmds.add_argument(
        "--maxp",
        help="number of processors",
        type=int,
        default=1)
    parser_runcmds.set_defaults(func=UR.run_commands)

    # ---------------------------------------------------------- test subcommand
    parser_test = subparsers.add_parser("test")
    parser_test.set_defaults(func=testcommand)
    testparsers = parser_test.add_subparsers(title="show options")

    # --- arm_opcodes ---
    test_arm_opcodes = testparsers.add_parser("arm_opcodes")
    test_arm_opcodes.add_argument("path", help="path to test arm-opcode testfile")
    test_arm_opcodes.add_argument("filename", help="name of arm-opcode testfile")
    test_arm_opcodes.set_defaults(func=TC.test_arm_opcodes)

    # --- run ---
    test_run = testparsers.add_parser("run")
    test_run.add_argument(
        "arch",
        help="architecture (x86, arm32, or mips32)",
        choices=["x86", "arm32", "mips32"])
    test_run.add_argument(
        "fileformat",
        help="file format (pe, or elf)",
        choices=["pe", "elf"])
    test_run.add_argument(
        "suite",
        help="number of test suite (e.g., 001)")
    test_run.add_argument(
        "test",
        help="number of test (e.g., 001)")
    test_run.set_defaults(func=TC.test_run)

    # --- run-parameterized ---
    test_run_parameterized = testparsers.add_parser("run_parameterized")
    test_run_parameterized.add_argument(
        "name", help="name of parameterized test set")
    test_run_parameterized.set_defaults(func=TC.test_run_parameterized)

    # --- runall ---
    test_runall = testparsers.add_parser("runall")
    test_runall.add_argument(
        "--arch",
        help="restrict to architecture",
        choices=["x86", "arm32", "mips32"])
    test_runall.add_argument(
        "--fileformat",
        help="restrict to file format",
        choices=["pe", "elf"])
    test_runall.set_defaults(func=TC.test_runall)

    # --- list ---
    test_list = testparsers.add_parser("list")
    test_list.add_argument(
        "--arch",
        help="restrict to architecture",
        choices=["x86", "arm32", "mips32"])
    test_list.add_argument(
        "--fileformat",
        help="restrict to file format",
        choices=["pe", "elf"])
    test_list.set_defaults(func=TC.test_list)

    # --- create ---
    test_create = testparsers.add_parser("create")
    test_create.add_argument(
        "specfile",
        help="name of json file that defines the test")
    test_create.set_defaults(func=TC.test_create)

    # -- parse --
    args = parser.parse_args()
    return args


if __name__ == '__main__':

    args = parse()
    args.func(args)
